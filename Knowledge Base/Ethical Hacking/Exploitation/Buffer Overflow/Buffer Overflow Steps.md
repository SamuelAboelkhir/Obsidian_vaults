---
tags:
- type/reference/ethical-hacking
- context/phase/exploitation
- topic/flow
- context/buffer-overflow
---

- Buffer overflow is based around sending too much data to a program in order to try and overflow its memory buffer and spill into the following memory buffer
- The goal is to reach a buffer called the EIP (Extended Instruction Pointer) which is a pointer or return address.
- We can use this address by pointing towards the direction that we want (malicious code) to gain reverse shell, and access to the target.
- **See:** [[Anatomy of Memory]]
# Steps
1. Spiking ^3a5df5
	1. [[Spiking]]
	2. A method that finds a vulnerable part of a program
	3. Meant for reconnaissance and discovery
2. Fuzzing
	1. Sending a bunch of characters to a program to see if we can break it
	2. It's more controlled than spiking and is meant to approximately find where in the stack memory the ESI is located
	3. The first script we make here is meant to more carefully break the server and return an approximate offset
	4. Using [[Hacking Tools#Metasploit|metasploit]] we can generate a string using `/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l [approximate_offset_found_in_the_first_fuzzing]` that we can use in another fuzzing script to get a value from the EIP that we give to metasploit to find the offset
3. Finding the Offset
	1. If we can break it we want to know when/where we can break it
	2. The next command is `/usr/share/metasploit framework/tools/exploit/pattern_offset.rb -l [approximate_position_found_in_the_first_fuzzing] -q [the_value_we_got_back_from_the_2nd_fuzzing]` and now we get the exact offset 
	3. The 2nd script is a modified version of the first one that uses the string returned by metasploit
4. Overwriting the EIP
	1. We use the Offset to overwrite the EIP
	2. The 3rd script uses the actual offset to confirm that we have taken over the EIP
5. Finding Bad Characters ^d6154c
	1. House clean up
	2. In this test, we take a list of generated hexvalues and add them to the script we used to overwrite the EIP
	3. The point is to filter out all bad chars that would cause the program to act up and break
	4. You need to find the bad characters by eye in immunity debugger. 
	5. This can be done by first left clicking on the ESP's value and then right click and choose follow dump
	6. What bad characters are, is any hexvalue that's replaced by B0, but only the first B0 in any sequence. Although you can still take out every single B0 to be safe and the shellcode will still work ^ebd4e0
6. Finding the Right Module
	1. Also house cleaning
	2. Meant for finding the execution vector or bypassing protection
	3. [Mona module](https://github.com/corelan/mona) can be of great help to find these unprotected DLLs or similar with no memory protection
		1. mona.py goes in the PyCommands folder in Immunity Inc
		2. You can then type `!mona modules` in the bar in immunity debugger to use it
	4. You need to find parts that have all false values to indicate they're unprotected
	5. The next part requires a tool called nasm_shell
		1. Locate it using `locate nasm_shell`
		2. Run the metasploit version
		3. This tools takes assembly code and returns hexvalue equivalent
		4. An example is `JMP ESP` whose equivalent is `FFE4`
		5. `!mona find -s "\xff\xe4" -m essfunc.dll` will give you return addresses for the unprotected part of the vulnserver program
		6. What's opcode?
		7. We insert the found hexvalue in reverse "little indian format for x86 architecture"
7. Generating Shellcode ^0dee88
	1. Helps us get the [[Exploitation#Netcat Reverse Shell|reverse shell]]
	2. The culmination of our previous work
	3. In this step we finally send our payload to gain access to the target, using [[Hacking Tools#Metasploit|metasploit]]
8. Achieving code execution